#include "objectQuery.hpp"

namespace objsearch {
    namespace objectquery {
	ObjectQuery::ObjectQuery(int argc, char *argv[]){
	    ros::init(argc, argv, "object_query");
	    ros::NodeHandle handle;


	    // Retrieve the directory containing the cloud to be processed
	    ROSUtil::getParam(handle, "/object_query/query_features", queryFile);
	    // Retrieve the directory containing the cloud of features generated by
	    // feature extraction
	    ROSUtil::getParam(handle, "/object_query/target_features", targetFile);
	    ROSUtil::getParam(handle, "/obj_search/raw_data_dir", dataPath);

	    // If the given cloud file corresponds to a file in the raw data directory,
	    // extract the remaining directories in the path of the file so that the
	    // data can be put into the output directory with the same path.
	    if (queryFile.compare(0, dataPath.size(), dataPath) == 0){
		dataSubDir = SysUtil::trimPath(std::string(queryFile, dataPath.size()), 1);
	    }

	    ROSUtil::getParam(handle, "/object_query/output_dir", outDir);
	    // If output is not specified, set the output directory to be the processed
	    // data directory specified by the global parameters.
	    if (std::string("NULL").compare(outDir) == 0) {
		ROSUtil::getParam(handle, "/obj_search/processed_data_dir", outDir);
	    }

	    // The output path for processed clouds is the subdirectory combined
	    // with the top level output directory. If dataSubDir is not
	    // initialised, then clouds are simply output to the top level
	    // output directory
	    outPath = SysUtil::combinePaths(outDir, dataSubDir);

	    pcl::PCDReader reader;
	    pcl::PCLPointCloud2 header;
	    reader.readHeader(targetFile, header);
    
	    if (header.fields[0].name.compare("shot") == 0) {
		doSearch<pcl::SHOT352>();
	    } 
	}

	template<typename DescType>
	void ObjectQuery::doSearch() {
	    pcl::PCDReader reader;
    
	    typename pcl::PointCloud<DescType>::Ptr targetCloud(new pcl::PointCloud<DescType>());
	    typename pcl::PointCloud<DescType>::Ptr queryCloud(new pcl::PointCloud<DescType>());
	    std::cout << reader.read(targetFile, *targetCloud) << std::endl;
	    std::cout << reader.read(queryFile, *queryCloud) << std::endl;

	    typename pcl::search::FlannSearch<DescType, flann::L2<float> > *search(new pcl::search::FlannSearch<DescType, flann::L2<float> >());
	    typename pcl::DefaultPointRepresentation<DescType>::ConstPtr shotRepr(new pcl::DefaultPointRepresentation<DescType>());
	    search->setPointRepresentation(shotRepr);
	    search->setInputCloud(targetCloud);
	
	    int k = 4;
	    std::vector<int> indices(k);
	    std::vector<float> square_dists(k);
	    search->nearestKSearch(queryCloud->points[0], k, indices, square_dists);

	    for (int i = 0; i < k; i++) {
		ROS_INFO("Index: %d, distance: %f", indices[i], square_dists[i]);
	    }
	}


    } // namespace objectquery
} // namespace objsearch

int main(int argc, char *argv[]) {
    objsearch::objectquery::ObjectQuery(argc, argv);
    
    return 0;
}
