#include "sysutil/sysutil.hpp"
#include "rosutil/rosutil.hpp"

#include <cmath>
#include <string>
#include <typeinfo>
#include <vector>

#include <ros/console.h>

#include <pcl/features/shot.h>
#include <pcl/features/usc.h>
#include <pcl/io/pcd_io.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/point_types.h>
#include <pcl/search/flann_search.h>
#include <pcl/search/impl/flann_search.hpp>
#include <pcl/search/pcl_search.h>

int main(int argc, char *argv[]) {
ros::init(argc, argv, "object_query");
    ros::NodeHandle handle;

    std::string queryFile;
    // Retrieve the directory containing the cloud to be processed
    ROSUtil::getParam(handle, "/object_query/query_features", queryFile);

    std::string targetFile;
    // Retrieve the directory containing the cloud of features generated by
    // feature extraction
    ROSUtil::getParam(handle, "/object_query/target_features", targetFile);

    std::string dataPath;
    ROSUtil::getParam(handle, "/obj_search/raw_data_dir", dataPath);

    // If the given cloud file corresponds to a file in the raw data directory,
    // extract the remaining directories in the path of the file so that the
    // data can be put into the output directory with the same path.
    std::string dataSubDir;
    if (queryFile.compare(0, dataPath.size(), dataPath) == 0){
	dataSubDir = SysUtil::trimPath(std::string(queryFile, dataPath.size()), 1);
    }

    std::string outDir;
    ROSUtil::getParam(handle, "/object_query/output_dir", outDir);
    // If output is not specified, set the output directory to be the processed
    // data directory specified by the global parameters.
    if (std::string("NULL").compare(outDir) == 0) {
	ROSUtil::getParam(handle, "/obj_search/processed_data_dir", outDir);
    }

    // The output path for processed clouds is the subdirectory combined
    // with the top level output directory. If dataSubDir is not
    // initialised, then clouds are simply output to the top level
    // output directory
    std::string outPath = SysUtil::combinePaths(outDir, dataSubDir);

    pcl::PCDReader reader;

    pcl::PCLPointCloud2 header;
    reader.readHeader(targetFile, header);

    
    std::string descField = header.fields[0].name;


    // TODO: this code is (probably) identical for all different types of
    // descriptors. Way too much duplication if it isn't poissible to somehow get the type template in at runtime. Seems like a pretty hard thing to do though.
    if (descField.compare("shot") == 0) {
	pcl::PointCloud<pcl::SHOT352>::Ptr targetCloud(new pcl::PointCloud<pcl::SHOT352>());
	pcl::PointCloud<pcl::SHOT352>::Ptr queryCloud(new pcl::PointCloud<pcl::SHOT352>());
	std::cout << reader.read(targetFile, *targetCloud) << std::endl;
	std::cout << reader.read(queryFile, *queryCloud) << std::endl;

	pcl::search::FlannSearch<pcl::SHOT352, flann::L2<float> > *search(new pcl::search::FlannSearch<pcl::SHOT352, flann::L2<float> >());
	pcl::DefaultPointRepresentation<pcl::SHOT352>::ConstPtr shotRepr(new pcl::DefaultPointRepresentation<pcl::SHOT352>());
	search->setPointRepresentation(shotRepr);
	search->setInputCloud(targetCloud);
	
	int k = 4;
	std::vector<int> indices(k);
	std::vector<float> square_dists(k);
	search->nearestKSearch(queryCloud->points[0], k, indices, square_dists);

	for (int i = 0; i < k; i++) {
	    ROS_INFO("Index: %d, distance: %f", indices[i], square_dists[i]);
	}

    }
    


    
    return 0;
}
