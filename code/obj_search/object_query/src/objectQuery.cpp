#include "objectQuery.hpp"

namespace objsearch {
    namespace objectquery {
	ObjectQuery::ObjectQuery(int argc, char *argv[]){
	    ros::init(argc, argv, "object_query");
	    ros::NodeHandle handle;

	    // Retrieve the directory containing the cloud to be processed
	    ROSUtil::getParam(handle, "/object_query/query_features", queryFile_);
	    // Retrieve the directory containing the cloud of features generated by
	    // feature extraction
	    ROSUtil::getParam(handle, "/object_query/target_features", targetFile_);

	    ROSUtil::getParam(handle, "/object_query/subdirs", keepNSubDirs_);
	    
	    // Extract the K parameter specified in the launch file. If it is
	    // still at the default value of -1, read the parameter from the
	    // param file instead.
	    ROSUtil::getParam(handle, "/object_query/K", K_);
	    if (K_ == -1){
		ROSUtil::getParam(handle, "/obj_search/object_query/K", K_);
	    }

	    ROSUtil::getParam(handle, "/obj_search/processed_data_dir", dataPath_);
	    ROSUtil::getParam(handle, "/object_query/output_dir", outDir_);
	    ROSUtil::getParam(handle, "/object_query/results_out", resultsOut_);
	    ROSUtil::getParam(handle, "/object_query/clusters_to_results", clustersToResults_);

	    ROSUtil::getParam(handle, "/object_query/x_step_hough", xStepHough_);
	    ROSUtil::getParam(handle, "/object_query/y_step_hough", yStepHough_);
	    ROSUtil::getParam(handle, "/object_query/z_step_hough", zStepHough_);

	    ROSUtil::getParam(handle, "/object_query/n_max_points", nMax_);
	    ROSUtil::getParam(handle, "/object_query/cluster_tolerance", clusterTolerance_);
	    ROSUtil::getParam(handle, "/object_query/cluster_minsize", clusterMinSize_);
	    ROSUtil::getParam(handle, "/object_query/cluster_maxsize", clusterMaxSize_);
	    ROSUtil::getParam(handle, "/object_query/extract_mult", extractRadiusMult_);

	    // make sure results output directory is a full path. If the string
	    // is null, then we output the results to the directory above the query file
	    if (!std::string("NULL").compare(resultsOut_) == 0){
		resultsOut_ = sysutil::fullDirPath(resultsOut_);
	    } else {
		if (sysutil::isDir(targetFile_)) {
		    resultsOut_ = sysutil::fullDirPath(targetFile_);
		} else {
		    resultsOut_ = sysutil::fullDirPath(sysutil::trimPath(queryFile_, 2));
		}
	    }

	    // If output is not specified, set the output directory to be the processed
	    // data directory specified by the global parameters.
	    if (clustersToResults_){
		outDir_ = resultsOut_;
	    } else if (std::string("NULL").compare(outDir_) == 0) {
		outDir_ = dataPath_;
	    }

	    // Query info is always the same, so initialise everything here.
	    // Stuff about the target will be initialised every loop in the
	    // doSearch function
	    
	    // extract the remaining directories in the path of the file so that
	    // the data can be put into the output directory with the same path
	    // following it.
	    if (queryFile_.compare(0, dataPath_.size(), dataPath_) == 0){
		dataSubDir_ = sysutil::trimPath(std::string(queryFile_, dataPath_.size()), 1);
	    }
	    
	    // The output path for processed clouds is the subdirectory combined
	    // with the top level output directory. If dataSubDir_ is not
	    // initialised, then clouds are simply output to the top level
	    // output directory. The output will be written to a location for
	    // the query cloud, for each of the target clouds used.
	    outPath_ = sysutil::fullDirPath(sysutil::combinePaths(outDir_, dataSubDir_));
	    ROS_INFO("Output path is %s", outPath_.c_str());
	    // the file containing the feature locations of the query file can
	    // be found in the same directory, with the same date-time stamp. We
	    // can use a regex to find the corresponding file, of which there
	    // should be only one. The query file format is something like
	    // originfile<descriptortype_interesttype_date_time.pcd
	    // remove the preceding path and the extension from the query file
	    std::string trimmedName = sysutil::removeExtension(queryFile_, -1);
	    ROS_INFO("Trimmed name is %s", trimmedName.c_str());
	    // we know that the date/time makes up the last 19 characters of the
	    // string, and we want to remove the preceding underscore as well
	    std::string dateTime = std::string(trimmedName.begin() + trimmedName.length() - 19,
					       trimmedName.end());
	    ROS_INFO("Date time is %s", dateTime.c_str());
	    
	    // remainder of the string containing information about the original
	    // name, interest and descriptor types
	    std::string remainder = std::string(trimmedName.begin(),
						trimmedName.begin() + trimmedName.length() - 20);
	    ROS_INFO("Remainder is %s", remainder.c_str());
	    
	    // we are interested in extracting the interest point type and the original filename
	    int indicator = remainder.find_last_of('_');
	    // interest type is the part of the string after the last _
	    interestType_ = std::string(remainder, indicator + 1);
	    
	    int aindicator = remainder.find_first_of('<');
	    featureType_ = std::string(remainder.begin() + aindicator + 1,
				       remainder.begin() + indicator);
	    ROS_INFO("Using query cloud with date %s, interest type %s, feature type %s",
		     dateTime.c_str(), interestType_.c_str(), featureType_.c_str());
	    // the original file name starts at the beginning of the string and
	    // ends at the first <
	    originalCloudFileName_ = std::string(remainder.begin(), remainder.begin() + aindicator);
	    ROS_INFO("Original cloud file name without extension is %s", originalCloudFileName_.c_str());
	    // we assume that query objects have their label name in the
	    // filename, following the string label_
	    std::string labelPrefix("label_");
	    size_t ind = originalCloudFileName_.find(labelPrefix);
	    if (ind == std::string::npos) {
		throw sysutil::objsearchexception("Filename did not contain label prefix - could not extract a label");
	    } else {
		queryObjectLabel_ = std::string(originalCloudFileName_, ind + labelPrefix.size());
	    }
	    
	    // now, find files in the directory which have the same interest
	    // type and date+time. There should be only one, if there are any at
	    // all.
	    std::vector<std::string> matches = sysutil::listFilesWithString(
		sysutil::trimPath(queryFile_, 1),
		std::regex(".*points_" + interestType_ + ".*" + dateTime + ".*"));

	    if (matches.size() == 0){
		ROS_INFO("No matches for descriptor location file of %s", queryFile_.c_str());
		exit(1);
	    }
	    
	    queryPointFile_ = matches[0];
	    pcl::PCDReader reader;
	    pcl::PCLPointCloud2 queryHeader;
	    reader.readHeader(queryFile_, queryHeader);
	    queryType_ = queryHeader.fields[0].name;
	    
	    ROS_INFO("Loading query feature points from %s", queryPointFile_.c_str());

	    std::string match;
	    ROSUtil::getParam(handle, "/object_query/match", match);
	    // Get all paths to the target clouds to check. This depends on
	    // whether the parameter given is a file or directory, and also
	    // whether a match string was given or not.
	    if (sysutil::isDir(targetFile_)) {
		if (match.compare("NULL") == 0) {
		    targetClouds_ = sysutil::listFilesWithString(targetFile_, "nonPlanes.pcd", true);
		} else { // otherwise, match the string and process those files
		    targetClouds_ = sysutil::listFilesWithString(targetFile_, match, true);
		}
	    } else { // is a file, so just process that
		targetClouds_.push_back(targetFile_);
	    }

	    // for simplicity, only look at clouds which have an annotation for
	    // the object that is being queried.
	    std::vector<int> toKeep;
	    for (size_t i = 0; i < targetClouds_.size(); i++) {
		ROS_INFO("Cloud %d, %s", (int)i, targetClouds_[i].c_str());
		// hack because regex doesn't work well.
		if (targetClouds_[i].find("points")){
		    continue;
		}
	    }

	    // error if there are no target clouds to look at.
	    if (targetClouds_.size() == 0) {
		ROS_INFO("No target clouds found in the specified location, or they were filtered out.");
		throw sysutil::objsearchexception("Did not extract any valid target clouds.");
	    }

	    std::sort(targetClouds_.begin(), targetClouds_.end());

	    // print some information about what files will be processed
	    size_t i;
	    for (i = 0; i < 10 && i < targetClouds_.size(); i++) {
		ROS_INFO("%s", targetClouds_[i].c_str());
	    }
	    if (i >= 10) {
		ROS_INFO("And more...");
	    }

	    std::string dataOutput = sysutil::fullDirPath(outPath_);


	    // Depending on the type of the descriptor in the cloud, we need to
	    // instantiate a different template for the search function
	    if (queryType_.find("shot") != std::string::npos) {
		// the only way to distinguish between colour shot and normal
		// shot is by checking the dimensionality of the descriptor
		int count = queryHeader.fields[0].count;
		if (count == 352) {
		    doSearch<pcl::SHOT352>();
		} else if (count == 1344) {
		    doSearch<pcl::SHOT1344>();
		} else {
		    ROS_ERROR("Unknown descriptor field specifier: %s", queryType_.c_str());
		    throw sysutil::objsearchexception("Unknown descriptor field specifier");;
		}
	    } else if (queryType_.find("pfh") != std::string::npos) {
		if (queryType_.compare("pfh") == 0) {
		    doSearch<pcl::PFHSignature125>();
		} else if (queryType_.compare("fpfh") == 0) {
		    doSearch<pcl::FPFHSignature33>();
		} else if (queryType_.compare("pfhrgb") == 0) {
		    doSearch<pcl::PFHRGBSignature250>();
		} else {
		    ROS_ERROR("Unknown descriptor field specifier: %s", queryType_.c_str());
		    throw sysutil::objsearchexception("Unknown descriptor field specifier");;
		}
	    } else if (queryType_.compare("shape_context") == 0) {
		doSearch<pcl::ShapeContext1980>();
	    } else {
		ROS_ERROR("Unknown descriptor field specifier: %s", queryType_.c_str());
                throw sysutil::objsearchexception("Unknown descriptor field specifier");;
	    }
	}

	/** 
	 * Extract information from the filename of a feature cloud
	 *
	 * @param fname the filename to get information from
	 * @param dateTime the date and time the features were extracted
	 * @param interestType the interest point selection method used
	 * @param featureType the type of feature used
	 * @param originalName the name of the file from which these features were extracted
	 */
	void ObjectQuery::extractFeatureFileInfo(const std::string& fname,
						 std::string& dateTime,
						 std::string& interestType,
						 std::string& featureType,
						 std::string& originalName) {
	    std::string trimmedName = sysutil::removeExtension(fname, -1);
	    // we know that the date/time makes up the last 19 characters of the
	    // string, and we want to remove the preceding underscore as well
	    dateTime = std::string(trimmedName.begin() + trimmedName.length() - 19,
					       trimmedName.end());
	    // remainder of the string containing information about the original
	    // name, interest and descriptor types
	    std::string remainder = std::string(trimmedName.begin(), trimmedName.begin() + trimmedName.length() - 20);

	    // we are interested in extracting the interest point type and the original filename
	    int indicator = remainder.find_last_of('_');
	    // interest type is the part of the string after the last _
	    interestType = std::string(remainder, indicator + 1);
	    int aindicator = remainder.find_first_of('<');
	    featureType = std::string(remainder.begin() + aindicator + 1,
				      remainder.begin() + indicator);
	    // the original file name starts at the beginning of the string and
	    // ends at the first <
	    originalName = std::string(remainder.begin(), remainder.begin() + aindicator);
	}

	bool ObjectQuery::initAndCheckPaths(std::string path) {
	    targetFile_ = path;
	    // Read the headers for the point clouds that were provided as
	    // input, and look at the field names to determine which descriptor
	    // type is stored in the cloud.
	    pcl::PCDReader reader;
	    pcl::PCLPointCloud2 targetHeader;
	    reader.readHeader(targetFile_, targetHeader);
	    std::string targetType = targetHeader.fields[0].name;

	    // The descriptors for both clouds must be the same, otherwise we
	    // cannot compare them.
	    if (queryType_.compare(targetType) != 0){
		ROS_ERROR("Fields of the two descriptor clouds do not match: \n"\
			  "Query: %s, target: %s", queryType_.c_str(), targetType.c_str());
		throw sysutil::objsearchexception("Fields of descriptors do not match.");
	    }

	    // get extra info out of the filename
	    std::string dateTime, interestType, featureType, originalName;
	    extractFeatureFileInfo(targetFile_, dateTime, interestType, featureType, originalName);
	    ROS_INFO("date is %s, interest type %s, feature type %s", dateTime.c_str(),
		     interestType.c_str(), featureType.c_str());
	    
	    // now, find files in the directory which have the same interest
	    // type and date+time. There should be only one, if there are any at
	    // all.
	    std::vector<std::string> matches = sysutil::listFilesWithString(sysutil::trimPath(targetFile_, 1), std::regex(".*points_" + interestType + ".*" + dateTime + ".*"));

	    if (matches.size() == 0){
		ROS_INFO("No matches for descriptor location file of %s", targetFile_.c_str());
		throw sysutil::objsearchexception("No matches for descriptor location file.");
	    }
	    
	    targetPointFile_ = matches[0];

	    // directory above the features directory
	    std::string targetPath = sysutil::fullDirPath(sysutil::trimPath(targetFile_, 2));
	    // file which contains the cloud that the features we will look at was taken from
	    originalTargetCloudFile_ = targetPath + originalName + ".pcd";
	    // output the cluster results to a new directory
	    if (clustersToResults_) {
		outPath_ = outDir_ + sysutil::trimPath(targetPath, -1 * keepNSubDirs_) + "clusters/";
	    } else {
		outPath_ = targetPath + "clusters/";
	    }

	    if (!sysutil::makeDirs(outPath_)) {
		ROS_INFO("Could not make output directory %s", outPath_.c_str());
		throw sysutil::objsearchexception("Failed to create output directory");
	    }

	    ROS_INFO("Loading target feature points from %s", targetPointFile_.c_str());
	    ROS_INFO("Original cloud is %s", originalTargetCloudFile_.c_str());
	    ROS_INFO("Clusters will be output to %s", outPath_.c_str());
	    
	    return true;
	}

	/** 
	 * Annotate points in the given cloud, using oriented bounding boxes
	 * computed from the annotated clouds.
	 *
	 * @param dir The top level room directory containing the cloud of
	 * interest (and more specifically the annotated clouds).
	 * @param cloud The cloud containing points to annotate.
	 * @param label the label of the specific annotation that we are
	 * interested in using to label points
	 * @param indices This vector will be populated with the indices of the
	 * points which have been labelled
	 * @param labels Will be populated with the labels of the points
	 */
	std::vector<pclutil::OrientedBoundingBox> ObjectQuery::annotatePointsOBB(
	    std::string dir, const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud,
	    std::vector<int>& indices, std::vector<std::string>& labels,
	    std::string queryLabel) {
	    // load all the annotated clouds and compute their bounding boxes.
	    // Don't care about rgb values
	    indices.clear();
	    labels.clear();
	    std::vector<pclutil::AnnotatedCloud<pcl::PointXYZ> > annotations
		= pclutil::getProcessedAnnotatedClouds<pcl::PointXYZ>(dir, queryLabel);
	    if (annotations.size() == 0){
		std::string error("No annotation clouds were found in annotatePointsOBB, directory " + dir + ", query label " + queryLabel);
		throw sysutil::objsearchexception(error);
	    }

	    // fill a vector with the bounding boxes of each of the annotated clouds
	    std::vector<pclutil::OrientedBoundingBox> bboxes;
	    for (auto it = annotations.begin(); it != annotations.end(); it++) {
		bboxes.push_back(pclutil::getOrientedBoundingBox(it->cloud, it->label));
	    }

	    // go through each point in the cloud given and check if it lies in
	    // any of the bounding boxes of objects. If it lies in multiple
	    // boxes, the point will be added to the indices and labels arrays
	    // multiple times.
	    pcl::PointCloud<pcl::PointXYZRGB>::Ptr transformed(
		new pcl::PointCloud<pcl::PointXYZRGB>());
	    for (size_t i = 0; i < annotations.size(); i++) {
		ROS_INFO("Checking bbox for %s", annotations[i].label.c_str());
		// transform the points in the cloud into the frame of the box.
		pcl::transformPointCloud(*cloud, *transformed, bboxes[i].transformInverse);

		std::string currentLabel = annotations[i].label;
		for (size_t j = 0; j < transformed->size(); j++) {
		    if (bboxes[i].contains(transformed->points[j], true)){
			indices.push_back(j);
			labels.push_back(currentLabel);
		    }
		}
	    }
	    return bboxes;
	}

	/** 
	 * Annotate points in a cloud loaded from a certain directory based on
	 * the annotations. Points in the given cloud will be compared to the
	 * annotated objects, and labelled with the label of the nearest object,
	 * but only if the point is within a euclidean distance of maxDist of
	 * the object. Uses nearest neighbour search for each point in the query
	 * cloud.
	 * 
	 * @param dir The top level room directory containing the cloud of
	 * interest.
	 * @param cloud The cloud containing points to annotate.
	 * @param indices This vector will be populated with the indices of the
	 * points which have been labelled
	 * @param labels Will be populated with the labels of the points
	 * @param distances Will be populated with the minimum distance of the point to its object
	 * @param maxDist The maximum distance from an object a point can be to
	 * still be considered part of the object
	 */
	void ObjectQuery::annotatePointsCloud(
	    std::string dir, const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud,
	    std::vector<int>& indices, std::vector<std::string>& labels,
	    std::vector<float>& distances, float maxDist) {

	    // extract the annotated clouds from the raw directory along with their labels
	    std::vector<pclutil::AnnotatedCloud<pcl::PointXYZRGB> > annotations
		= pclutil::getProcessedAnnotatedClouds<pcl::PointXYZRGB>(dir);

	    pcl::KdTreeFLANN<pcl::PointXYZRGB> searchTree;
	    // want to find the minimum distance and the corresponding index.

	    pcl::PointXYZRGB point;
	    int minInd = 0; // index of the point closest to the current object
	    float minDist = std::numeric_limits<float>::max(); // minimum distance from the point to an object
	    std::vector<int> nn(1); // index of nearest point on annotated object
	    std::vector<float> pointDistance(1); // distance of point from annotated object

	    // look through all the points in the cloud to be annotated
	    for (size_t i = 0; i < cloud->size(); i++) {

		point = cloud->points[i];

		// reset the min index and distance for the new point
		minInd = 0;
		minDist = std::numeric_limits<float>::max();
		// look through all the annotated object clouds and find the nearest
		// neighbour to the point received.
		for (size_t j = 0; j < annotations.size(); j++) {
		    searchTree.setInputCloud(annotations[j].cloud);
		    searchTree.nearestKSearch(point, 1, nn, pointDistance); // search for 1-nn
		    // update index and minimum distance to the object
		    if (pointDistance[0] < minDist){
			minInd = j;
			minDist = pointDistance[0];
		    }
		}

		// if the point is within the requested distance of the object,
		// push information about the point onto the vectors
		if (minDist < maxDist){
		    indices.push_back(i);
		    labels.push_back(annotations[minInd].label);
		    distances.push_back(minDist);
		    ROS_INFO("Point %d label %s", (int)i, labels.back().c_str());
		} else {
		    ROS_INFO("Point %d not labelled", (int)i);
		}
		
	    }
	}

	/** 
	 * Perform hough voting given the information provided. For each index
	 * in the indices given, which refer to points in the targetPoints
	 * cloud, we add a vote to a cell in 3d space. The votes should indicate
	 * regions where objects of interest lie
	 * 
	 * @param targetPoints The points to use to index into the 3d space
	 * which the grid defines
	 * @param indices The indices of the points at
	 * which we wish to place votes
	 * @param distances The distances to the points
	 */
	pclutil::Grid3D ObjectQuery::houghVoting(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& targetPoints,
				      const std::vector<std::vector<int> >& indices,
				      const std::vector<std::vector<float> >& distances) {
	    // to construct the grid, need to know the bounds of the target
	    // points. Doesn't really matter if we waste some space on extra
	    // cells because the grid is not rotated (hopefully)
	    pcl::PointXYZRGB min;
	    pcl::PointXYZRGB max;
	    pcl::getMinMax3D(*targetPoints, min, max);
	    ROS_INFO("min: %f, %f, %f", min.x, min.y, min.z);
	    ROS_INFO("max: %f, %f, %f", max.x, max.y, max.z);
	    ROS_INFO("Grid dimensions %f, %f, %f", max.x - min.x, max.y - min.y, max.z - min.z);
	    pclutil::Grid3D grid(max.x - min.x, max.y - min.y, max.z - min.z,
				 xStepHough_, yStepHough_, zStepHough_,
				 min.x, min.y, min.z);

	    // Go through all points in the nearest neighbours
	    for (size_t i = 0; i < indices.size(); i++) {
		for (size_t j = 0; j < indices[i].size(); j++) {
		    pcl::PointXYZRGB cur = targetPoints->points[indices[i][j]];
		    grid.at(cur.x, cur.y, cur.z)++;
		}
	    }

	    return grid;
	}

	/** 
	 * Do a nearest neighbour search for the features in the query cloud in
	 * the target cloud. 
	 * 
	 */
	template<typename DescType>
	void ObjectQuery::doSearch() {
	    ROS_INFO("Doing descriptor search.");
	    

	    std::string dateTime = sysutil::getDateTimeString();
	    std::string fullResultsDir = sysutil::fullDirPath(resultsOut_ + "query_results/" + queryObjectLabel_ + "/" + interestType_ + "_" + featureType_ + "-" + dateTime);
	    if (clustersToResults_) {
		outDir_ = fullResultsDir;
	    }
	    ROS_INFO("Results will be output to directory %s", fullResultsDir.c_str());
	    if (!sysutil::makeDirs(fullResultsDir)){
		ROS_INFO("Could not create directory %s for results output", fullResultsDir.c_str());
		throw sysutil::objsearchexception("Failed to create output directory");
	    }

	    std::string dataFile = fullResultsDir + "queryresults" + "_" + dateTime + ".txt";
	    ROS_INFO("Dumping parameters");
	    // Dump parameters used for this run
	    // dangerous, but otherwise annoying to output all parameters individually.
	    std::string command("rosparam dump " + dataFile);
	    ROS_INFO("Calling system with command %s", command.c_str());
	    int ret = system(command.c_str());
	    ROS_INFO("System command returned %d", ret);
	    
	    pcl::PCDReader reader;

	    // load the original object file so that we can extract its OBB,
	    // just to get the size of the object.
	    pcl::PointCloud<pcl::PointXYZ>::Ptr origQuery(new pcl::PointCloud<pcl::PointXYZ>);
	    // trim the path of the query file to get the directory above it
	    std::string origCloudFile(sysutil::fullDirPath(sysutil::trimPath(queryFile_, 2))
				      + originalCloudFileName_ + ".pcd");
	    ROS_INFO("Reading original query cloud file from %s", origCloudFile.c_str());
	    
	    reader.read(origCloudFile, *origQuery);
	    ROS_INFO("Getting bounding box of query cloud.");
	    pclutil::OrientedBoundingBox queryBbox = pclutil::getOrientedBoundingBox(origQuery,
										     queryObjectLabel_);

	    // Read the input clouds for the target and query descriptors. We
	    // want to find descriptors in targetFeatures which are close to
	    // those in queryFeatures. Need to use typename here because of
	    // dependent scope - what it is depends on the instantiation of the
	    // template argument. Each point in the *Points clouds corresponds
	    // to the location of the feature at the same index in the *Features
	    // clouds
	    typename pcl::PointCloud<DescType>::Ptr queryFeatures(new pcl::PointCloud<DescType>());
	    pcl::PointCloud<pcl::PointXYZRGB>::Ptr queryPoints(new pcl::PointCloud<pcl::PointXYZRGB>());
	    ROS_INFO("Reading query points and features.");
	    reader.read(queryPointFile_, *queryPoints);
	    reader.read(queryFile_, *queryFeatures);

	    std::vector<QueryInfo> infoVec;
	    
	    // loop over all clouds in the target cloud vector
	    for (size_t i = 0; i < targetClouds_.size(); i++) {
		ROS_INFO("====================Processing target cloud %d of %d====================\n%s", (int)i + 1, (int)targetClouds_.size(), targetClouds_[i].c_str());
		// initialise struct to store information about timings and so on
		QueryInfo info = {};

		
		// Do a check to make sure the feature types match. If not, skip
		// this target cloud
		try {
		    initAndCheckPaths(targetClouds_[i]);
		} catch (sysutil::objsearchexception& e) {
		    ROS_INFO("Target file failed path check:");
		    ROS_INFO("%s", e.what());
		    continue;
		}

		// load the points and computed features for the target cloud
		pcl::PointCloud<pcl::PointXYZRGB>::Ptr targetPoints(new pcl::PointCloud<pcl::PointXYZRGB>());
		typename pcl::PointCloud<DescType>::Ptr targetFeatures(new pcl::PointCloud<DescType>());

		// Create a flannsearch object to use to do the NN search
		typename pcl::search::FlannSearch<DescType, flann::L2_Simple<float> >
		    *search(new pcl::search::FlannSearch<DescType, flann::L2_Simple<float> >());
		// Flann needs to know the point representation so that it can
		// convert it to its internal format
		typename pcl::DefaultPointRepresentation<DescType>::ConstPtr
		    descRepr(new pcl::DefaultPointRepresentation<DescType>());
		search->setPointRepresentation(descRepr);

		info.fname = targetClouds_[i];
		reader.read(targetClouds_[i], *targetFeatures);
		reader.read(targetPointFile_, *targetPoints);
		search->setInputCloud(targetFeatures);
	    
		std::vector<int> indicesTarget;
		std::vector<std::string> labelsTarget;

		ROS_INFO("Starting search");
		// Loop over all points in the query cloud
		std::vector<std::vector<int> > nearest((int)queryFeatures->size());
		std::vector<std::vector<float> > square_dists((int)queryFeatures->size());
		// Initialise vectors to store the closest K points to the query point.
		ros::Time queryStart = ros::Time::now();
		for (int j = 0; j < queryFeatures->size(); j++) {
		    if (j % 50 == 0 && j > 0) {
			ROS_INFO("Query point %d of %d", j + 1, (int)queryFeatures->size());
		    }
		    // some features may have nan values and will crash if not excluded.
		    if (!pclutil::isValid(queryFeatures->points[j])){
			continue;
		    }
		    // Search for the closest K points to the query point
		    search->nearestKSearch(queryFeatures->points[j], K_,
					   nearest[j], square_dists[j]);
		}
		info.queryTime = (ros::Time::now() - queryStart).toSec();
		ROS_INFO("Finished finding neighbours");

		ROS_INFO("Starting hough voting");
		// do hough voting using the computed neighbours
		ros::Time houghStart = ros::Time::now();
		pclutil::Grid3D grid = houghVoting(targetPoints, nearest, square_dists);
		info.houghTime = (ros::Time::now() - houghStart).toSec();
		ROS_INFO("Hough voting done");

		pcl::PointCloud<pcl::PointXYZRGB>::Ptr voteCloud(new pcl::PointCloud<pcl::PointXYZRGB>);
		// convert the grid to a point cloud with rgb values
		// representing the number of votes in each cell
		std::vector<int> cellIndices = grid.toPointCloud(voteCloud);
		
		std::string out = sysutil::fullDirPath(outPath_) + "houghVotes_"
		    + queryObjectLabel_ + "_" + featureType_ + "_" + interestType_;
		pcl::PCDWriter writer;
		writer.write<pcl::PointXYZRGB>(out + ".pcd", *voteCloud, true);

		// find the n points in the hough grid with the maximum value -
		// this should indicate the points in the target cloud which most
		// closely match the query object
		std::vector<std::pair<int, int> > maxPoints = grid.getMaxN(nMax_);
		
		// create a cloud containing only the top n points
		pcl::PointCloud<pcl::PointXYZRGB>::Ptr topCloud(new pcl::PointCloud<pcl::PointXYZRGB>);
		topCloud->resize(maxPoints.size());
		for (size_t j = 0; j < maxPoints.size(); j++) {
		    pcl::PointXYZ p = grid.cellCentreFromIndex(maxPoints[j].first);
		    topCloud->points[j].x = p.x;
		    topCloud->points[j].y = p.y;
		    topCloud->points[j].z = p.z;
		    pclutil::rgb colour = pclutil::getHeatColour(maxPoints[j].second,
								 maxPoints[0].second);
		    topCloud->points[j].r = colour.r * 255;
		    topCloud->points[j].g = colour.g * 255;
		    topCloud->points[j].b = colour.b * 255;
		}
		writer.write<pcl::PointXYZRGB>(out + "_top.pcd", *topCloud, true);

		ROS_INFO("Finding clusters");
		// find clusters in the space of the top n points, with the user
		// specified tolerances and min and max cluster sizes
		pcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZRGB>);
		tree->setInputCloud(topCloud);
		std::vector<pcl::PointIndices> clusterIndices;
		pcl::EuclideanClusterExtraction<pcl::PointXYZRGB> ec;
		ec.setClusterTolerance(clusterTolerance_);
		ec.setMinClusterSize(clusterMinSize_);
		ec.setMaxClusterSize(clusterMaxSize_);
		ec.setSearchMethod(tree);
		ec.setInputCloud(topCloud);
		ros::Time clusterStart = ros::Time::now();
		ec.extract(clusterIndices);
		info.clusterTime = (ros::Time::now() - clusterStart).toSec();		

		if (clusterIndices.size() == 0) {
		    ROS_INFO("!!!!! No clusters found. !!!!!");
		    infoVec.push_back(QueryInfo());
		    continue;
		}
		ROS_INFO("Found clusters");

		// maybe try doing this on the the whole set of hough votes?
		// i.e. find all unique points in the hough vote cloud in the
		// radius of the points which make up the cluster and add their
		// scores as well - potential for more accuracy?
		// score the clusters based on the total number of votes they contain
		// vector will store the cluster index and score so we can sort it
		std::vector<ClusterInfo> clusterDetails(clusterIndices.size());
		std::vector<pcl::PointCloud<pcl::PointXYZRGB>::Ptr > clusterClouds;
		// loop over all clusters - each index of this vector contains
		// another vector with the indices of the points in the clusters
		// from the point of view of the topCloud. So, need to use the
		// topCloud indices that we have in the maxPoints vector to get
		// the correct values for the score
		ROS_INFO("Creating cluster clouds");
		for (size_t j = 0; j < clusterIndices.size(); j++) {
			pcl::PointCloud<pcl::PointXYZRGB>::Ptr clusterCloud(new pcl::PointCloud<pcl::PointXYZRGB>);
			// loop over indices in the individual cluster
			clusterDetails[j].index = j; // keep track of the index of this cluster

			// loop over the indices of the points in this cluster
			pcl::PointXYZ centroid(0,0,0);
			for (auto it = clusterIndices[j].indices.begin();
			     it != clusterIndices[j].indices.end(); it++) {
			    // *it index refers to the index in topCloud, which
			    // is constructed from the maxPoints vector. Use
			    // the score values stored in maxPoints
			    clusterDetails[j].score += maxPoints[*it].second;
			    // push the points at the indices that this cluster
			    // contains onto the cloud for the cluster
			    pcl::PointXYZRGB p = topCloud->points[*it];
			    // store values to compute the centroid for this cluster
			    centroid.x += p.x;
			    centroid.y += p.y;
			    centroid.z += p.z;
			    clusterCloud->points.push_back(p);
			}
			centroid.x /= clusterCloud->points.size();
			centroid.y /= clusterCloud->points.size();
			centroid.z /= clusterCloud->points.size();
			clusterDetails[j].centroid = centroid;
			clusterDetails[j].points = clusterCloud->points.size();
			
			clusterCloud->width = clusterCloud->points.size();
			clusterCloud->height = 1;
			clusterCloud->is_dense = true;
			clusterClouds.push_back(clusterCloud);
		}
		ROS_INFO("Done");

		auto comp = [](ClusterInfo p, ClusterInfo q) {
		    return p.score > q.score;
		};
		// sort the clusters to get them in order of the scores
		std::sort(clusterDetails.begin(), clusterDetails.end(), comp);

		info.nClusters = clusterDetails.size(); // save the number of clusters extracted
		// base name for outputting clusters and other stuff
		std::string cloudOut = std::string(sysutil::fullDirPath(outPath_).c_str()
						   + queryObjectLabel_);
		for (size_t j = 0; j < clusterDetails.size(); j++) {
		    ROS_INFO("Cluster %d has %d points with score %d (%f avg/pt). Original index was %d",
			     (int)j, (int)clusterIndices[j].indices.size(),
			     clusterDetails[j].score,
			     clusterDetails[j].score/(float)clusterClouds[clusterDetails[j].index]->size(),
			     clusterDetails[j].index);

		    pcl::PointXYZ c = clusterDetails[j].centroid;
		    ROS_INFO("Cluster centroid is (%f, %f, %f)", c.x, c.y, c.z);
		    std::string outLoc(cloudOut + "_cluster_" + featureType_
				       + "_" + interestType_ + "_" + std::to_string(j)
				       + "_" + std::to_string(clusterDetails[j].score) + ".pcd");
		    ROS_INFO("Outputting cluster cloud to %s", outLoc.c_str());
		    clusterDetails[j].clusterCloud = outLoc;
		    clusterDetails[j].parentCloud = originalTargetCloudFile_;
		    // need to extract the correct index of the cloud by using
		    // the index stored in the clusterscores vector
		    writer.write<pcl::PointXYZRGB>(outLoc,
						   *clusterClouds[clusterDetails[j].index], true);
		}
		
		pcl::PointCloud<pcl::PointXYZRGB>::Ptr originalPoints(new pcl::PointCloud<pcl::PointXYZRGB>());

		ROS_INFO("Reading original target cloud from %s", originalTargetCloudFile_.c_str());
		reader.read(originalTargetCloudFile_, *originalPoints);

		
		// cut out a region that is double the size of the bounding box
		// of the original query object from the original target cloud
		// around the centroid of each cluster
//		pcl::PointXYZ extents(queryBbox.extents.x * 2, queryBbox.extents.y * 2, queryBbox.extents.z * 2);
		// the radius is twice the largest extent, plus a little extra
		// on top just in case
		float radius;
		if (queryBbox.extents.x > queryBbox.extents.y) {
		    radius = queryBbox.extents.x;
		} else {
		    radius = queryBbox.extents.y;
		}

		if (radius < queryBbox.extents.z) {
		    radius = queryBbox.extents.z;
		}

		radius *= extractRadiusMult_; // multiply it a little bit

		for (size_t j = 0; j < clusterDetails.size(); j++) {
		    // pcl::PointCloud<pcl::PointXYZRGB>::Ptr filtered =
		    // 	extractClusterRegionBox(originalPoints,
		    // 				centroids[clusterScores[i].first],
		    // 				extents);
		    pcl::PointCloud<pcl::PointXYZRGB>::Ptr filtered =
			extractClusterRegionSphere(originalPoints,
						   clusterDetails[j].centroid,
						   radius);
		    std::string outLoc(cloudOut + "_region_" + featureType_
				       + "_" + interestType_ + "_" + std::to_string(j) + ".pcd");
		    ROS_INFO("Outputting region cloud to %s", outLoc.c_str());
		    clusterDetails[j].regionCloud = outLoc;
		    writer.write<pcl::PointXYZRGB>(outLoc, *filtered, true);
		}
		// put the cluster with the top score into the information
		// vector, after we fill it with information about the files it uses
		info.topCluster = clusterDetails[0];
		
		ROS_INFO("Starting post-processing.");
		postProcess(grid, voteCloud, cellIndices, maxPoints, info, clusterDetails);
		ROS_INFO("Post processing finished");
		infoVec.push_back(info);
	    }
	    writeInfo(dataFile, infoVec);
	}

	void ObjectQuery::writeInfo(std::string outFile, const std::vector<QueryInfo>& infoVec) {
	    std::ofstream file;
	    file.open(outFile, std::ios::app);
	    file << "BEGIN_DATA" << std::endl;
	    file << "# fname t_query t_hough t_cluster cluster_n cluster_scores cluster_points cluster_inobb n_hough_tot nonzero_hough hough_votes boxpts boxvotes maxpts maxvotes maxboxpts maxboxvotes hough_hist box_hist max_hist boxmax_hist" << std::endl;
	    std::vector<ClusterInfo> topClusters;
	    for (size_t i = 0; i < infoVec.size(); i++) {
		QueryInfo info = infoVec[i];
		file << info.fname.c_str() << " " << info.queryTime << " " << info.houghTime << " "
		     << info.clusterTime << " " << info.nClusters << " "
		     << info.clusterScores.c_str() << " " << info.clusterPoints.c_str() << " "
		     << info.clusterCentroidInOBB.c_str() << " " << info.pointsTotal << " "
		     << info.pointsNonZero << " " << info.votesTotal << " "
		     << info.pointsInBox << " " << info.votesInBox << " "
		     << info.pointsMaxTotal << " " << info.votesMaxTotal << " "
		     << info.pointsMaxInBox << " " << info.votesMaxInBox << " "
		     << info.pointHistogram.c_str() << " " << info.boxHistogram.c_str() << " "
		     << info.maxHistogram.c_str() << " " << info.boxMaxHistogram.c_str() << std::endl;
		
		// populate the top regions so we can sort them
		topClusters.push_back(infoVec[i].topCluster);
	    }
	    static const auto comp = [](ClusterInfo a, ClusterInfo b) {return a.score > b.score;};
	    std::sort(topClusters.begin(), topClusters.end(), comp);
	    
	    file << "BEGIN_FILES" << std::endl;
	    file << "# score parent cluster region" << std::endl;
	    for (size_t i = 0; i < topClusters.size(); i++) {
		ClusterInfo r = topClusters[i];
		file << r.score << " " << r.parentCloud.c_str() << " "
		     << r.clusterCloud.c_str() << " " << r.regionCloud.c_str() << std::endl;
	    }
	    file.close();
	}

	/** 
	 * Extracts the box region defined by the centroid and extents given
	 *
	 * @param cloud The cloud from which to extract points
	 * @param centroid the centroid of the box within which extracted points are to lie
	 * @param extents the extents of the box - half of each dimension
	 * 
	 * @return Point cloud containing points from \p cloud which are inside the box
	 */
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr ObjectQuery::extractClusterRegionBox(
	    const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud,
	    const pcl::PointXYZ& centroid, const pcl::PointXYZ& extents) {
	    
	    pcl::PointCloud<pcl::PointXYZRGB>::Ptr filtered(new pcl::PointCloud<pcl::PointXYZRGB>());
	    pcl::PassThrough<pcl::PointXYZRGB> pass;
	    pass.setInputCloud(cloud);
	    pass.setFilterFieldName("x");
	    pass.setFilterLimits(centroid.x - extents.x, centroid.x + extents.x);
	    pass.filter(*filtered);
	    pass.setInputCloud(filtered);
	    pass.setFilterFieldName("y");
	    pass.setFilterLimits(centroid.y - extents.y, centroid.y + extents.y);
	    pass.filter(*filtered);
	    pass.setFilterFieldName("z");
	    pass.setFilterLimits(centroid.z - extents.z, centroid.z + extents.z);
	    pass.filter(*filtered);
	    
	    return filtered;
	}

	/** 
	 * Extracts the spherical region defined by the centroid and radius given
	 *
	 * @param cloud The cloud from which to extract points
	 * @param centre the centre of the sphere within which extracted points are to lie
	 * @param radius Radius of sphere to use
	 * 
	 * @return Point cloud containing points from \p cloud which are inside the box
	 */
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr ObjectQuery::extractClusterRegionSphere(
	    const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud, const pcl::PointXYZ& centre, float radius) {
	    
	    pcl::PointCloud<pcl::PointXYZRGB>::Ptr filtered(new pcl::PointCloud<pcl::PointXYZRGB>());

	    pcl::KdTreeFLANN<pcl::PointXYZRGB> tree;
	    tree.setInputCloud(cloud);
	    std::vector<int> indices;
	    std::vector<float> distances;
	    pcl::PointXYZRGB c;
	    c.x = centre.x; c.y = centre.y; c.z = centre.z;
	    c.r = 0; c.g = 0; c.b = 0;
	    tree.radiusSearch(c, radius, indices, distances);
	    for (size_t i = 0 ; i < indices.size(); i++) {
		filtered->push_back(cloud->points[indices[i]]);
	    }

	    return filtered;
	}


	/** 
	 * Perform some post processing on the results from the query. Creates
	 * some clouds from the hough grid, and uses additional knowledge about
	 * the bounding box of the query object to look at the points in that region
	 * 
	 * @param grid the hough voting grid that was populated
	 * @param maxPoints vector of pairs of indices and values at those indices in the grid
	 * @param cellIndices vector of indices corresponding to the indices of nonzero cells in the hough grid
	 * @param voteCloud the hough grid
	 * @param clusterDetails information about clusters extracted from hough space
	 * @param info info struct to fill with data
	 */
	
void ObjectQuery::postProcess(const pclutil::Grid3D& grid,
				      const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& voteCloud,
				      const std::vector<int> cellIndices,
				      const std::vector<std::pair<int, int> >& maxPoints,
				      QueryInfo& info, std::vector<ClusterInfo> clusterDetails) {
	    int total = grid.getValuesTotal();
	    info.votesTotal = total;
	    int empty = grid.getEmptyTotal();
	    int size = grid.size();
	    info.pointsTotal = size;
	    info.pointsNonZero = size - empty;
	    ROS_INFO("Hough grid has size %d, containing %d votes. %d cells have no votes -> %d cells have votes", size, total, empty, size - empty);

	    std::vector<int> gridHist = grid.valueHistogram();
	    info.pointHistogram = vectorToString(gridHist);
	    ROS_INFO("Histogram of grid values: %s", info.pointHistogram.c_str());
	    
	    std::vector<int> maxHistogram(maxPoints[0].second + 1);
	    info.votesMaxTotal = 0;
	    info.pointsMaxTotal = maxPoints.size();
	    for (size_t i = 0; i < maxPoints.size(); i++) {
		maxHistogram[maxPoints[i].second]++;
		info.votesMaxTotal += maxPoints[i].second;
	    }
	    info.maxHistogram = vectorToString(maxHistogram);

	    ROS_INFO("Max point has %d votes.", maxPoints[0].second);
	    ROS_INFO("%d max points have %d votes", (int)maxPoints.size(), info.votesMaxTotal);
	    ROS_INFO("Max points histogram: %s", info.maxHistogram.c_str());

	    std::string scores;
	    std::string points;
	    //and put information about clusters into the info struct
	    for (size_t i = 0; i < clusterDetails.size(); i++) {
		std::string end = (i + 1 == clusterDetails.size() ? "" : ",");
		scores += std::to_string(clusterDetails[i].score) + end;
		points += std::to_string(clusterDetails[i].points) + end;
	    }
	    info.clusterScores = scores;
	    info.clusterPoints = points;

	    // will be filled with all of the points in the hough cloud
	    // which were within the bounding box of the annotation cloud
	    // with the label of the query object we are using.
	    std::vector<int> indices;
	    // we know what the label will be, but can't nicely write a
	    // function which would allow default vector param
	    std::vector<std::string> labels;
	    std::vector<pclutil::OrientedBoundingBox> bboxes;
	    try {
		// there should be only one bbox that results from this.
		bboxes = annotatePointsOBB(sysutil::trimPath(targetPointFile_, 2), voteCloud,
					   indices, labels, queryObjectLabel_);
	    } catch (sysutil::objsearchexception& e) {
		ROS_INFO("%s", e.what());

		// the exception is that there were no annotations, so can
		// return without going further since we can't compute things to
		// do with the obb - but need to set stuff in the queryinfo
		// object to indicate this
		info.clusterCentroidInOBB = "-1";
		info.pointsInBox = -1;
		info.votesInBox = -1;
		info.pointsMaxInBox = -1;
		info.votesMaxInBox = -1;
		info.boxHistogram = "-1";
		info.boxMaxHistogram = "-1";
		
		return;
	    }

	    // check whether cluster centres are in the obb
	    std::string inOBB;
	    for (size_t i = 0; i < clusterDetails.size(); i++) {
		// dont put a comma on the end if this is the last item
		std::string end = (i + 1 == clusterDetails.size() ? "" : ",");
		inOBB += (bboxes[0].contains(clusterDetails[i].centroid, false) ? "1" : "0") + end;
	    }

	    info.clusterCentroidInOBB = inOBB;
	    
	    info.pointsInBox = indices.size();
	    info.votesInBox = 0;
	    info.pointsMaxInBox = 0;
	    info.votesMaxInBox = 0;
	    std::vector<int> boxHistogram(maxPoints[0].second + 1);
	    std::vector<int> boxMaxHistogram(maxPoints[0].second + 1);
	    for (size_t i = 0; i < indices.size(); i++) {
		info.votesInBox += grid.at(cellIndices[indices[i]]);
		boxHistogram[grid.at(cellIndices[indices[i]])]++;
		// check the max points vector to see if this point is in
		// there as well, and if it is increment the values for the
		// max box.
		for (size_t j = 0; j < maxPoints.size(); j++) {
		    // if the cell index of one of the maximum points
		    // matches the cell index of the point in the OBB that
		    // we are looking at, then that max point is also in the
		    // OBB.
		    if (maxPoints[j].first == cellIndices[indices[i]]) {
			info.pointsMaxInBox++;
			info.votesMaxInBox += maxPoints[j].second;
			boxMaxHistogram[maxPoints[j].second]++;
		    }
		}
	    }
	    info.boxMaxHistogram = vectorToString(boxMaxHistogram);
	    info.boxHistogram = vectorToString(boxHistogram);
	    ROS_INFO("Box histogram: %s", info.boxHistogram.c_str());
	    ROS_INFO("Box max histogram: %s", info.boxMaxHistogram.c_str());
		
	    ROS_INFO("Points inside annotation bbox for hough cloud: %d of %d total grid points >0", info.pointsInBox, (int)voteCloud->size());
	    ROS_INFO("Votes inside annotation bbox for hough cloud: %d of %d total grid votes", info.votesInBox, grid.getValuesTotal());
	    ROS_INFO("Max points inside annotation bbox for hough cloud: %d of %d total max points", info.pointsMaxInBox, (int)maxPoints.size());
	    ROS_INFO("Max Votes inside annotation bbox for hough cloud: %d of %d total max votes", info.votesMaxInBox, info.votesMaxTotal);

	}

	std::string ObjectQuery::vectorToString(std::vector<int> vec) {
	    std::string str;
	    for (size_t i = 0; i < vec.size(); i++) {
		str += std::to_string(vec[i]) + (i + 1 == vec.size() ? "" : ",");		
	    }
	    return str;
	}

    } // namespace objectquery
} // namespace obj_search

int main(int argc, char *argv[]) {
    objsearch::objectquery::ObjectQuery oq(argc, argv);
}
